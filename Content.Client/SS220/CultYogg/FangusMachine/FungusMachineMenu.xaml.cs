using System.Numerics;
using Content.Shared.SS220.CultYogg.FungusMachine.Systems;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using FancyWindow = Content.Client.UserInterface.Controls.FancyWindow;
using Content.Shared.IdentityManagement;

namespace Content.Client.SS220.CultYogg.FangusMachine
{
    [GenerateTypedNameReferences]
    public sealed partial class FungusMachineMenu : FancyWindow
    {
        [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
        [Dependency] private readonly IEntityManager _entityManager = default!;

        private readonly Dictionary<EntProtoId, EntityUid> _dummies = [];

        public event Action<ItemList.ItemListSelectedEventArgs>? OnItemSelected;
        public event Action<string>? OnSearchChanged;

        public FungusMachineMenu()
        {
            MinSize = new Vector2(x: 200, y: 150);
			SetSize = new Vector2(x: 250, y: 150);
            RobustXamlLoader.Load(this);
            IoCManager.InjectDependencies(this);

            SearchBar.OnTextChanged += _ =>
            {
                OnSearchChanged?.Invoke(SearchBar.Text);
            };

            FungusContents.OnItemSelected += args =>
            {
                OnItemSelected?.Invoke(args);
            };
        }

        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            if (!disposing)
                return;

            foreach (var entity in _dummies.Values)
            {
                _entityManager.QueueDeleteEntity(entity);
            }
            _dummies.Clear();
        }

        public void Populate(List<FungusMachineInventoryEntry> inventory, out List<int> filteredInventory,  string? filter = null)
        {
            filteredInventory = new();

            while (inventory.Count != FungusContents.Count)
            {
                if (inventory.Count > FungusContents.Count)
                    FungusContents.AddItem(string.Empty);
                else
                    FungusContents.RemoveAt(FungusContents.Count - 1);
            }

            var longestEntry = string.Empty;
            var spriteSystem = IoCManager.Resolve<IEntitySystemManager>().GetEntitySystem<SpriteSystem>();

            var filterCount = 0;
            for (var i = 0; i < inventory.Count; i++)
            {
                var entry = inventory[i];
                var fungusItem = FungusContents[i - filterCount];
                fungusItem.Text = string.Empty;
                fungusItem.Icon = null;

                if (!_dummies.TryGetValue(entry.Id, out var dummy))
                {
                    dummy = _entityManager.Spawn(entry.Id);
                    _dummies.Add(entry.Id, dummy);
                }

                var itemName = Identity.Name(dummy, _entityManager);
                Texture? icon = null;
                if (_prototypeManager.TryIndex<EntityPrototype>(entry.Id, out var prototype))
                {
                    icon = spriteSystem.GetPrototypeIcon(prototype).Default;
                }

                if (!string.IsNullOrEmpty(filter) &&
                    !itemName.ToLowerInvariant().Contains(filter.Trim().ToLowerInvariant()))
                {
                    FungusContents.Remove(fungusItem);
                    filterCount++;
                    continue;
                }

                if (itemName.Length > longestEntry.Length)
                    longestEntry = itemName;

                fungusItem.Text = $"{itemName}";
                fungusItem.Icon = icon;
                filteredInventory.Add(i);
            }

            SetSizeAfterUpdate(longestEntry.Length, inventory.Count);
        }

        private void SetSizeAfterUpdate(int longestEntryLength, int contentCount)
        {
            SetSize = new Vector2(
                x: Math.Clamp((longestEntryLength + 2) * 12, 250, 300),
                y: Math.Clamp(contentCount * 50, 150, 350));
        }
    }
}
